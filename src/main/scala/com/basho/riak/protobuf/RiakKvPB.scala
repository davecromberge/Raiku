// Generated by ScalaBuff, the Scala Protocol Buffers compiler. DO NOT EDIT!
// source: riak_kv.proto

package com.basho.riak.protobuf

//import "riak.proto"

final case class RpbGetClientIdResp(
  `clientId`: com.google.protobuf.ByteString = com.google.protobuf.ByteString.EMPTY) extends com.google.protobuf.GeneratedMessageLite
    with com.google.protobuf.MessageLite.Builder
    with Message[RpbGetClientIdResp] {

  def writeTo(output: com.google.protobuf.CodedOutputStream) {
    output.writeBytes(1, `clientId`)
  }

  lazy val getSerializedSize = {
    import com.google.protobuf.CodedOutputStream._
    var size = 0
    size += computeBytesSize(1, `clientId`)

    size
  }

  def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): RpbGetClientIdResp = {
    import com.google.protobuf.ExtensionRegistryLite.{ getEmptyRegistry ⇒ _emptyRegistry }
    var __clientId: com.google.protobuf.ByteString = com.google.protobuf.ByteString.EMPTY

      def __newMerged = RpbGetClientIdResp(
        __clientId)
    while (true) in.readTag match {
      case 0       ⇒ return __newMerged
      case 10      ⇒ __clientId = in.readBytes()
      case default ⇒ if (!in.skipField(default)) return __newMerged
    }
    null
  }

  def mergeFrom(m: RpbGetClientIdResp) = {
    RpbGetClientIdResp(
      m.`clientId`)
  }

  def getDefaultInstanceForType = RpbGetClientIdResp.defaultInstance
  def clear = getDefaultInstanceForType
  def isInitialized = true
  def build = this
  def buildPartial = this
  def newBuilderForType = this
  def toBuilder = this
}

object RpbGetClientIdResp {
  @reflect.BeanProperty val defaultInstance = new RpbGetClientIdResp()

  val CLIENT_ID_FIELD_NUMBER = 1

}
final case class RpbSetClientIdReq(
  `clientId`: com.google.protobuf.ByteString = com.google.protobuf.ByteString.EMPTY) extends com.google.protobuf.GeneratedMessageLite
    with com.google.protobuf.MessageLite.Builder
    with Message[RpbSetClientIdReq] {

  def writeTo(output: com.google.protobuf.CodedOutputStream) {
    output.writeBytes(1, `clientId`)
  }

  lazy val getSerializedSize = {
    import com.google.protobuf.CodedOutputStream._
    var size = 0
    size += computeBytesSize(1, `clientId`)

    size
  }

  def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): RpbSetClientIdReq = {
    import com.google.protobuf.ExtensionRegistryLite.{ getEmptyRegistry ⇒ _emptyRegistry }
    var __clientId: com.google.protobuf.ByteString = com.google.protobuf.ByteString.EMPTY

      def __newMerged = RpbSetClientIdReq(
        __clientId)
    while (true) in.readTag match {
      case 0       ⇒ return __newMerged
      case 10      ⇒ __clientId = in.readBytes()
      case default ⇒ if (!in.skipField(default)) return __newMerged
    }
    null
  }

  def mergeFrom(m: RpbSetClientIdReq) = {
    RpbSetClientIdReq(
      m.`clientId`)
  }

  def getDefaultInstanceForType = RpbSetClientIdReq.defaultInstance
  def clear = getDefaultInstanceForType
  def isInitialized = true
  def build = this
  def buildPartial = this
  def newBuilderForType = this
  def toBuilder = this
}

object RpbSetClientIdReq {
  @reflect.BeanProperty val defaultInstance = new RpbSetClientIdReq()

  val CLIENT_ID_FIELD_NUMBER = 1

}
final case class RpbGetReq(
  `bucket`: com.google.protobuf.ByteString = com.google.protobuf.ByteString.EMPTY,
  `key`: com.google.protobuf.ByteString = com.google.protobuf.ByteString.EMPTY,
  `r`: Option[Int] = None,
  `pr`: Option[Int] = None,
  `basicQuorum`: Option[Boolean] = None,
  `notfoundOk`: Option[Boolean] = None,
  `ifModified`: Option[com.google.protobuf.ByteString] = None,
  `head`: Option[Boolean] = None,
  `deletedvclock`: Option[Boolean] = None,
  `timeout`: Option[Int] = None,
  `sloppyQuorum`: Option[Boolean] = None,
  `nVal`: Option[Int] = None) extends com.google.protobuf.GeneratedMessageLite
    with com.google.protobuf.MessageLite.Builder
    with Message[RpbGetReq] {

  def setR(_f: Int) = copy(`r` = _f)
  def setPr(_f: Int) = copy(`pr` = _f)
  def setBasicQuorum(_f: Boolean) = copy(`basicQuorum` = _f)
  def setNotfoundOk(_f: Boolean) = copy(`notfoundOk` = _f)
  def setIfModified(_f: com.google.protobuf.ByteString) = copy(`ifModified` = _f)
  def setHead(_f: Boolean) = copy(`head` = _f)
  def setDeletedvclock(_f: Boolean) = copy(`deletedvclock` = _f)
  def setTimeout(_f: Int) = copy(`timeout` = _f)
  def setSloppyQuorum(_f: Boolean) = copy(`sloppyQuorum` = _f)
  def setNVal(_f: Int) = copy(`nVal` = _f)

  def clearR = copy(`r` = None)
  def clearPr = copy(`pr` = None)
  def clearBasicQuorum = copy(`basicQuorum` = None)
  def clearNotfoundOk = copy(`notfoundOk` = None)
  def clearIfModified = copy(`ifModified` = None)
  def clearHead = copy(`head` = None)
  def clearDeletedvclock = copy(`deletedvclock` = None)
  def clearTimeout = copy(`timeout` = None)
  def clearSloppyQuorum = copy(`sloppyQuorum` = None)
  def clearNVal = copy(`nVal` = None)

  def writeTo(output: com.google.protobuf.CodedOutputStream) {
    output.writeBytes(1, `bucket`)
    output.writeBytes(2, `key`)
    if (`r`.isDefined) output.writeUInt32(3, `r`.get)
    if (`pr`.isDefined) output.writeUInt32(4, `pr`.get)
    if (`basicQuorum`.isDefined) output.writeBool(5, `basicQuorum`.get)
    if (`notfoundOk`.isDefined) output.writeBool(6, `notfoundOk`.get)
    if (`ifModified`.isDefined) output.writeBytes(7, `ifModified`.get)
    if (`head`.isDefined) output.writeBool(8, `head`.get)
    if (`deletedvclock`.isDefined) output.writeBool(9, `deletedvclock`.get)
    if (`timeout`.isDefined) output.writeUInt32(10, `timeout`.get)
    if (`sloppyQuorum`.isDefined) output.writeBool(11, `sloppyQuorum`.get)
    if (`nVal`.isDefined) output.writeUInt32(12, `nVal`.get)
  }

  lazy val getSerializedSize = {
    import com.google.protobuf.CodedOutputStream._
    var size = 0
    size += computeBytesSize(1, `bucket`)
    size += computeBytesSize(2, `key`)
    if (`r`.isDefined) size += computeUInt32Size(3, `r`.get)
    if (`pr`.isDefined) size += computeUInt32Size(4, `pr`.get)
    if (`basicQuorum`.isDefined) size += computeBoolSize(5, `basicQuorum`.get)
    if (`notfoundOk`.isDefined) size += computeBoolSize(6, `notfoundOk`.get)
    if (`ifModified`.isDefined) size += computeBytesSize(7, `ifModified`.get)
    if (`head`.isDefined) size += computeBoolSize(8, `head`.get)
    if (`deletedvclock`.isDefined) size += computeBoolSize(9, `deletedvclock`.get)
    if (`timeout`.isDefined) size += computeUInt32Size(10, `timeout`.get)
    if (`sloppyQuorum`.isDefined) size += computeBoolSize(11, `sloppyQuorum`.get)
    if (`nVal`.isDefined) size += computeUInt32Size(12, `nVal`.get)

    size
  }

  def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): RpbGetReq = {
    import com.google.protobuf.ExtensionRegistryLite.{ getEmptyRegistry ⇒ _emptyRegistry }
    var __bucket: com.google.protobuf.ByteString = com.google.protobuf.ByteString.EMPTY
    var __key: com.google.protobuf.ByteString = com.google.protobuf.ByteString.EMPTY
    var __r: Option[Int] = `r`
    var __pr: Option[Int] = `pr`
    var __basicQuorum: Option[Boolean] = `basicQuorum`
    var __notfoundOk: Option[Boolean] = `notfoundOk`
    var __ifModified: Option[com.google.protobuf.ByteString] = `ifModified`
    var __head: Option[Boolean] = `head`
    var __deletedvclock: Option[Boolean] = `deletedvclock`
    var __timeout: Option[Int] = `timeout`
    var __sloppyQuorum: Option[Boolean] = `sloppyQuorum`
    var __nVal: Option[Int] = `nVal`

      def __newMerged = RpbGetReq(
        __bucket,
        __key,
        __r,
        __pr,
        __basicQuorum,
        __notfoundOk,
        __ifModified,
        __head,
        __deletedvclock,
        __timeout,
        __sloppyQuorum,
        __nVal)
    while (true) in.readTag match {
      case 0       ⇒ return __newMerged
      case 10      ⇒ __bucket = in.readBytes()
      case 18      ⇒ __key = in.readBytes()
      case 24      ⇒ __r = in.readUInt32()
      case 32      ⇒ __pr = in.readUInt32()
      case 40      ⇒ __basicQuorum = in.readBool()
      case 48      ⇒ __notfoundOk = in.readBool()
      case 58      ⇒ __ifModified = in.readBytes()
      case 64      ⇒ __head = in.readBool()
      case 72      ⇒ __deletedvclock = in.readBool()
      case 80      ⇒ __timeout = in.readUInt32()
      case 88      ⇒ __sloppyQuorum = in.readBool()
      case 96      ⇒ __nVal = in.readUInt32()
      case default ⇒ if (!in.skipField(default)) return __newMerged
    }
    null
  }

  def mergeFrom(m: RpbGetReq) = {
    RpbGetReq(
      m.`bucket`,
      m.`key`,
      m.`r`.orElse(`r`),
      m.`pr`.orElse(`pr`),
      m.`basicQuorum`.orElse(`basicQuorum`),
      m.`notfoundOk`.orElse(`notfoundOk`),
      m.`ifModified`.orElse(`ifModified`),
      m.`head`.orElse(`head`),
      m.`deletedvclock`.orElse(`deletedvclock`),
      m.`timeout`.orElse(`timeout`),
      m.`sloppyQuorum`.orElse(`sloppyQuorum`),
      m.`nVal`.orElse(`nVal`))
  }

  def getDefaultInstanceForType = RpbGetReq.defaultInstance
  def clear = getDefaultInstanceForType
  def isInitialized = true
  def build = this
  def buildPartial = this
  def newBuilderForType = this
  def toBuilder = this
}

object RpbGetReq {
  @reflect.BeanProperty val defaultInstance = new RpbGetReq()

  val BUCKET_FIELD_NUMBER = 1
  val KEY_FIELD_NUMBER = 2
  val R_FIELD_NUMBER = 3
  val PR_FIELD_NUMBER = 4
  val BASIC_QUORUM_FIELD_NUMBER = 5
  val NOTFOUND_OK_FIELD_NUMBER = 6
  val IF_MODIFIED_FIELD_NUMBER = 7
  val HEAD_FIELD_NUMBER = 8
  val DELETEDVCLOCK_FIELD_NUMBER = 9
  val TIMEOUT_FIELD_NUMBER = 10
  val SLOPPY_QUORUM_FIELD_NUMBER = 11
  val N_VAL_FIELD_NUMBER = 12

}
final case class RpbGetResp(
  `content`: Vector[RpbContent] = Vector.empty[RpbContent],
  `vclock`: Option[com.google.protobuf.ByteString] = None,
  `unchanged`: Option[Boolean] = None) extends com.google.protobuf.GeneratedMessageLite
    with com.google.protobuf.MessageLite.Builder
    with Message[RpbGetResp] {

  def setContent(_i: Int, _v: RpbContent) = copy(`content` = `content`.updated(_i, _v))
  def addContent(_f: RpbContent) = copy(`content` = `content` :+ _f)
  def addAllContent(_f: RpbContent*) = copy(`content` = `content` ++ _f)
  def addAllContent(_f: TraversableOnce[RpbContent]) = copy(`content` = `content` ++ _f)
  def setVclock(_f: com.google.protobuf.ByteString) = copy(`vclock` = _f)
  def setUnchanged(_f: Boolean) = copy(`unchanged` = _f)

  def clearContent = copy(`content` = Vector.empty[RpbContent])
  def clearVclock = copy(`vclock` = None)
  def clearUnchanged = copy(`unchanged` = None)

  def writeTo(output: com.google.protobuf.CodedOutputStream) {
    for (_v ← `content`) output.writeMessage(1, _v)
    if (`vclock`.isDefined) output.writeBytes(2, `vclock`.get)
    if (`unchanged`.isDefined) output.writeBool(3, `unchanged`.get)
  }

  lazy val getSerializedSize = {
    import com.google.protobuf.CodedOutputStream._
    var size = 0
    for (_v ← `content`) size += computeMessageSize(1, _v)
    if (`vclock`.isDefined) size += computeBytesSize(2, `vclock`.get)
    if (`unchanged`.isDefined) size += computeBoolSize(3, `unchanged`.get)

    size
  }

  def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): RpbGetResp = {
    import com.google.protobuf.ExtensionRegistryLite.{ getEmptyRegistry ⇒ _emptyRegistry }
    val __content: collection.mutable.Buffer[RpbContent] = `content`.toBuffer
    var __vclock: Option[com.google.protobuf.ByteString] = `vclock`
    var __unchanged: Option[Boolean] = `unchanged`

      def __newMerged = RpbGetResp(
        Vector(__content: _*),
        __vclock,
        __unchanged)
    while (true) in.readTag match {
      case 0       ⇒ return __newMerged
      case 10      ⇒ __content += readMessage[RpbContent](in, RpbContent.defaultInstance, _emptyRegistry)
      case 18      ⇒ __vclock = in.readBytes()
      case 24      ⇒ __unchanged = in.readBool()
      case default ⇒ if (!in.skipField(default)) return __newMerged
    }
    null
  }

  def mergeFrom(m: RpbGetResp) = {
    RpbGetResp(
      `content` ++ m.`content`,
      m.`vclock`.orElse(`vclock`),
      m.`unchanged`.orElse(`unchanged`))
  }

  def getDefaultInstanceForType = RpbGetResp.defaultInstance
  def clear = getDefaultInstanceForType
  def isInitialized = true
  def build = this
  def buildPartial = this
  def newBuilderForType = this
  def toBuilder = this
}

object RpbGetResp {
  @reflect.BeanProperty val defaultInstance = new RpbGetResp()

  val CONTENT_FIELD_NUMBER = 1
  val VCLOCK_FIELD_NUMBER = 2
  val UNCHANGED_FIELD_NUMBER = 3

}
final case class RpbPutReq(
  `bucket`: com.google.protobuf.ByteString = com.google.protobuf.ByteString.EMPTY,
  `key`: Option[com.google.protobuf.ByteString] = None,
  `vclock`: Option[com.google.protobuf.ByteString] = None,
  `content`: RpbContent = RpbContent.defaultInstance,
  `w`: Option[Int] = None,
  `dw`: Option[Int] = None,
  `returnBody`: Option[Boolean] = None,
  `pw`: Option[Int] = None,
  `ifNotModified`: Option[Boolean] = None,
  `ifNoneMatch`: Option[Boolean] = None,
  `returnHead`: Option[Boolean] = None,
  `timeout`: Option[Int] = None,
  `asis`: Option[Boolean] = None,
  `sloppyQuorum`: Option[Boolean] = None,
  `nVal`: Option[Int] = None) extends com.google.protobuf.GeneratedMessageLite
    with com.google.protobuf.MessageLite.Builder
    with Message[RpbPutReq] {

  def setKey(_f: com.google.protobuf.ByteString) = copy(`key` = _f)
  def setVclock(_f: com.google.protobuf.ByteString) = copy(`vclock` = _f)
  def setW(_f: Int) = copy(`w` = _f)
  def setDw(_f: Int) = copy(`dw` = _f)
  def setReturnBody(_f: Boolean) = copy(`returnBody` = _f)
  def setPw(_f: Int) = copy(`pw` = _f)
  def setIfNotModified(_f: Boolean) = copy(`ifNotModified` = _f)
  def setIfNoneMatch(_f: Boolean) = copy(`ifNoneMatch` = _f)
  def setReturnHead(_f: Boolean) = copy(`returnHead` = _f)
  def setTimeout(_f: Int) = copy(`timeout` = _f)
  def setAsis(_f: Boolean) = copy(`asis` = _f)
  def setSloppyQuorum(_f: Boolean) = copy(`sloppyQuorum` = _f)
  def setNVal(_f: Int) = copy(`nVal` = _f)

  def clearKey = copy(`key` = None)
  def clearVclock = copy(`vclock` = None)
  def clearW = copy(`w` = None)
  def clearDw = copy(`dw` = None)
  def clearReturnBody = copy(`returnBody` = None)
  def clearPw = copy(`pw` = None)
  def clearIfNotModified = copy(`ifNotModified` = None)
  def clearIfNoneMatch = copy(`ifNoneMatch` = None)
  def clearReturnHead = copy(`returnHead` = None)
  def clearTimeout = copy(`timeout` = None)
  def clearAsis = copy(`asis` = None)
  def clearSloppyQuorum = copy(`sloppyQuorum` = None)
  def clearNVal = copy(`nVal` = None)

  def writeTo(output: com.google.protobuf.CodedOutputStream) {
    output.writeBytes(1, `bucket`)
    if (`key`.isDefined) output.writeBytes(2, `key`.get)
    if (`vclock`.isDefined) output.writeBytes(3, `vclock`.get)
    output.writeMessage(4, `content`)
    if (`w`.isDefined) output.writeUInt32(5, `w`.get)
    if (`dw`.isDefined) output.writeUInt32(6, `dw`.get)
    if (`returnBody`.isDefined) output.writeBool(7, `returnBody`.get)
    if (`pw`.isDefined) output.writeUInt32(8, `pw`.get)
    if (`ifNotModified`.isDefined) output.writeBool(9, `ifNotModified`.get)
    if (`ifNoneMatch`.isDefined) output.writeBool(10, `ifNoneMatch`.get)
    if (`returnHead`.isDefined) output.writeBool(11, `returnHead`.get)
    if (`timeout`.isDefined) output.writeUInt32(12, `timeout`.get)
    if (`asis`.isDefined) output.writeBool(13, `asis`.get)
    if (`sloppyQuorum`.isDefined) output.writeBool(14, `sloppyQuorum`.get)
    if (`nVal`.isDefined) output.writeUInt32(15, `nVal`.get)
  }

  lazy val getSerializedSize = {
    import com.google.protobuf.CodedOutputStream._
    var size = 0
    size += computeBytesSize(1, `bucket`)
    if (`key`.isDefined) size += computeBytesSize(2, `key`.get)
    if (`vclock`.isDefined) size += computeBytesSize(3, `vclock`.get)
    size += computeMessageSize(4, `content`)
    if (`w`.isDefined) size += computeUInt32Size(5, `w`.get)
    if (`dw`.isDefined) size += computeUInt32Size(6, `dw`.get)
    if (`returnBody`.isDefined) size += computeBoolSize(7, `returnBody`.get)
    if (`pw`.isDefined) size += computeUInt32Size(8, `pw`.get)
    if (`ifNotModified`.isDefined) size += computeBoolSize(9, `ifNotModified`.get)
    if (`ifNoneMatch`.isDefined) size += computeBoolSize(10, `ifNoneMatch`.get)
    if (`returnHead`.isDefined) size += computeBoolSize(11, `returnHead`.get)
    if (`timeout`.isDefined) size += computeUInt32Size(12, `timeout`.get)
    if (`asis`.isDefined) size += computeBoolSize(13, `asis`.get)
    if (`sloppyQuorum`.isDefined) size += computeBoolSize(14, `sloppyQuorum`.get)
    if (`nVal`.isDefined) size += computeUInt32Size(15, `nVal`.get)

    size
  }

  def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): RpbPutReq = {
    import com.google.protobuf.ExtensionRegistryLite.{ getEmptyRegistry ⇒ _emptyRegistry }
    var __bucket: com.google.protobuf.ByteString = com.google.protobuf.ByteString.EMPTY
    var __key: Option[com.google.protobuf.ByteString] = `key`
    var __vclock: Option[com.google.protobuf.ByteString] = `vclock`
    var __content: RpbContent = RpbContent.defaultInstance
    var __w: Option[Int] = `w`
    var __dw: Option[Int] = `dw`
    var __returnBody: Option[Boolean] = `returnBody`
    var __pw: Option[Int] = `pw`
    var __ifNotModified: Option[Boolean] = `ifNotModified`
    var __ifNoneMatch: Option[Boolean] = `ifNoneMatch`
    var __returnHead: Option[Boolean] = `returnHead`
    var __timeout: Option[Int] = `timeout`
    var __asis: Option[Boolean] = `asis`
    var __sloppyQuorum: Option[Boolean] = `sloppyQuorum`
    var __nVal: Option[Int] = `nVal`

      def __newMerged = RpbPutReq(
        __bucket,
        __key,
        __vclock,
        __content,
        __w,
        __dw,
        __returnBody,
        __pw,
        __ifNotModified,
        __ifNoneMatch,
        __returnHead,
        __timeout,
        __asis,
        __sloppyQuorum,
        __nVal)
    while (true) in.readTag match {
      case 0       ⇒ return __newMerged
      case 10      ⇒ __bucket = in.readBytes()
      case 18      ⇒ __key = in.readBytes()
      case 26      ⇒ __vclock = in.readBytes()
      case 34      ⇒ __content = readMessage[RpbContent](in, __content, _emptyRegistry)
      case 40      ⇒ __w = in.readUInt32()
      case 48      ⇒ __dw = in.readUInt32()
      case 56      ⇒ __returnBody = in.readBool()
      case 64      ⇒ __pw = in.readUInt32()
      case 72      ⇒ __ifNotModified = in.readBool()
      case 80      ⇒ __ifNoneMatch = in.readBool()
      case 88      ⇒ __returnHead = in.readBool()
      case 96      ⇒ __timeout = in.readUInt32()
      case 104     ⇒ __asis = in.readBool()
      case 112     ⇒ __sloppyQuorum = in.readBool()
      case 120     ⇒ __nVal = in.readUInt32()
      case default ⇒ if (!in.skipField(default)) return __newMerged
    }
    null
  }

  def mergeFrom(m: RpbPutReq) = {
    RpbPutReq(
      m.`bucket`,
      m.`key`.orElse(`key`),
      m.`vclock`.orElse(`vclock`),
      m.`content`,
      m.`w`.orElse(`w`),
      m.`dw`.orElse(`dw`),
      m.`returnBody`.orElse(`returnBody`),
      m.`pw`.orElse(`pw`),
      m.`ifNotModified`.orElse(`ifNotModified`),
      m.`ifNoneMatch`.orElse(`ifNoneMatch`),
      m.`returnHead`.orElse(`returnHead`),
      m.`timeout`.orElse(`timeout`),
      m.`asis`.orElse(`asis`),
      m.`sloppyQuorum`.orElse(`sloppyQuorum`),
      m.`nVal`.orElse(`nVal`))
  }

  def getDefaultInstanceForType = RpbPutReq.defaultInstance
  def clear = getDefaultInstanceForType
  def isInitialized = true
  def build = this
  def buildPartial = this
  def newBuilderForType = this
  def toBuilder = this
}

object RpbPutReq {
  @reflect.BeanProperty val defaultInstance = new RpbPutReq()

  val BUCKET_FIELD_NUMBER = 1
  val KEY_FIELD_NUMBER = 2
  val VCLOCK_FIELD_NUMBER = 3
  val CONTENT_FIELD_NUMBER = 4
  val W_FIELD_NUMBER = 5
  val DW_FIELD_NUMBER = 6
  val RETURN_BODY_FIELD_NUMBER = 7
  val PW_FIELD_NUMBER = 8
  val IF_NOT_MODIFIED_FIELD_NUMBER = 9
  val IF_NONE_MATCH_FIELD_NUMBER = 10
  val RETURN_HEAD_FIELD_NUMBER = 11
  val TIMEOUT_FIELD_NUMBER = 12
  val ASIS_FIELD_NUMBER = 13
  val SLOPPY_QUORUM_FIELD_NUMBER = 14
  val N_VAL_FIELD_NUMBER = 15

}
final case class RpbPutResp(
  `content`: Vector[RpbContent] = Vector.empty[RpbContent],
  `vclock`: Option[com.google.protobuf.ByteString] = None,
  `key`: Option[com.google.protobuf.ByteString] = None) extends com.google.protobuf.GeneratedMessageLite
    with com.google.protobuf.MessageLite.Builder
    with Message[RpbPutResp] {

  def setContent(_i: Int, _v: RpbContent) = copy(`content` = `content`.updated(_i, _v))
  def addContent(_f: RpbContent) = copy(`content` = `content` :+ _f)
  def addAllContent(_f: RpbContent*) = copy(`content` = `content` ++ _f)
  def addAllContent(_f: TraversableOnce[RpbContent]) = copy(`content` = `content` ++ _f)
  def setVclock(_f: com.google.protobuf.ByteString) = copy(`vclock` = _f)
  def setKey(_f: com.google.protobuf.ByteString) = copy(`key` = _f)

  def clearContent = copy(`content` = Vector.empty[RpbContent])
  def clearVclock = copy(`vclock` = None)
  def clearKey = copy(`key` = None)

  def writeTo(output: com.google.protobuf.CodedOutputStream) {
    for (_v ← `content`) output.writeMessage(1, _v)
    if (`vclock`.isDefined) output.writeBytes(2, `vclock`.get)
    if (`key`.isDefined) output.writeBytes(3, `key`.get)
  }

  lazy val getSerializedSize = {
    import com.google.protobuf.CodedOutputStream._
    var size = 0
    for (_v ← `content`) size += computeMessageSize(1, _v)
    if (`vclock`.isDefined) size += computeBytesSize(2, `vclock`.get)
    if (`key`.isDefined) size += computeBytesSize(3, `key`.get)

    size
  }

  def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): RpbPutResp = {
    import com.google.protobuf.ExtensionRegistryLite.{ getEmptyRegistry ⇒ _emptyRegistry }
    val __content: collection.mutable.Buffer[RpbContent] = `content`.toBuffer
    var __vclock: Option[com.google.protobuf.ByteString] = `vclock`
    var __key: Option[com.google.protobuf.ByteString] = `key`

      def __newMerged = RpbPutResp(
        Vector(__content: _*),
        __vclock,
        __key)
    while (true) in.readTag match {
      case 0       ⇒ return __newMerged
      case 10      ⇒ __content += readMessage[RpbContent](in, RpbContent.defaultInstance, _emptyRegistry)
      case 18      ⇒ __vclock = in.readBytes()
      case 26      ⇒ __key = in.readBytes()
      case default ⇒ if (!in.skipField(default)) return __newMerged
    }
    null
  }

  def mergeFrom(m: RpbPutResp) = {
    RpbPutResp(
      `content` ++ m.`content`,
      m.`vclock`.orElse(`vclock`),
      m.`key`.orElse(`key`))
  }

  def getDefaultInstanceForType = RpbPutResp.defaultInstance
  def clear = getDefaultInstanceForType
  def isInitialized = true
  def build = this
  def buildPartial = this
  def newBuilderForType = this
  def toBuilder = this
}

object RpbPutResp {
  @reflect.BeanProperty val defaultInstance = new RpbPutResp()

  val CONTENT_FIELD_NUMBER = 1
  val VCLOCK_FIELD_NUMBER = 2
  val KEY_FIELD_NUMBER = 3

}
final case class RpbDelReq(
  `bucket`: com.google.protobuf.ByteString = com.google.protobuf.ByteString.EMPTY,
  `key`: com.google.protobuf.ByteString = com.google.protobuf.ByteString.EMPTY,
  `rw`: Option[Int] = None,
  `vclock`: Option[com.google.protobuf.ByteString] = None,
  `r`: Option[Int] = None,
  `w`: Option[Int] = None,
  `pr`: Option[Int] = None,
  `pw`: Option[Int] = None,
  `dw`: Option[Int] = None,
  `timeout`: Option[Int] = None,
  `sloppyQuorum`: Option[Boolean] = None,
  `nVal`: Option[Int] = None) extends com.google.protobuf.GeneratedMessageLite
    with com.google.protobuf.MessageLite.Builder
    with Message[RpbDelReq] {

  def setRw(_f: Int) = copy(`rw` = _f)
  def setVclock(_f: com.google.protobuf.ByteString) = copy(`vclock` = _f)
  def setR(_f: Int) = copy(`r` = _f)
  def setW(_f: Int) = copy(`w` = _f)
  def setPr(_f: Int) = copy(`pr` = _f)
  def setPw(_f: Int) = copy(`pw` = _f)
  def setDw(_f: Int) = copy(`dw` = _f)
  def setTimeout(_f: Int) = copy(`timeout` = _f)
  def setSloppyQuorum(_f: Boolean) = copy(`sloppyQuorum` = _f)
  def setNVal(_f: Int) = copy(`nVal` = _f)

  def clearRw = copy(`rw` = None)
  def clearVclock = copy(`vclock` = None)
  def clearR = copy(`r` = None)
  def clearW = copy(`w` = None)
  def clearPr = copy(`pr` = None)
  def clearPw = copy(`pw` = None)
  def clearDw = copy(`dw` = None)
  def clearTimeout = copy(`timeout` = None)
  def clearSloppyQuorum = copy(`sloppyQuorum` = None)
  def clearNVal = copy(`nVal` = None)

  def writeTo(output: com.google.protobuf.CodedOutputStream) {
    output.writeBytes(1, `bucket`)
    output.writeBytes(2, `key`)
    if (`rw`.isDefined) output.writeUInt32(3, `rw`.get)
    if (`vclock`.isDefined) output.writeBytes(4, `vclock`.get)
    if (`r`.isDefined) output.writeUInt32(5, `r`.get)
    if (`w`.isDefined) output.writeUInt32(6, `w`.get)
    if (`pr`.isDefined) output.writeUInt32(7, `pr`.get)
    if (`pw`.isDefined) output.writeUInt32(8, `pw`.get)
    if (`dw`.isDefined) output.writeUInt32(9, `dw`.get)
    if (`timeout`.isDefined) output.writeUInt32(10, `timeout`.get)
    if (`sloppyQuorum`.isDefined) output.writeBool(11, `sloppyQuorum`.get)
    if (`nVal`.isDefined) output.writeUInt32(12, `nVal`.get)
  }

  lazy val getSerializedSize = {
    import com.google.protobuf.CodedOutputStream._
    var size = 0
    size += computeBytesSize(1, `bucket`)
    size += computeBytesSize(2, `key`)
    if (`rw`.isDefined) size += computeUInt32Size(3, `rw`.get)
    if (`vclock`.isDefined) size += computeBytesSize(4, `vclock`.get)
    if (`r`.isDefined) size += computeUInt32Size(5, `r`.get)
    if (`w`.isDefined) size += computeUInt32Size(6, `w`.get)
    if (`pr`.isDefined) size += computeUInt32Size(7, `pr`.get)
    if (`pw`.isDefined) size += computeUInt32Size(8, `pw`.get)
    if (`dw`.isDefined) size += computeUInt32Size(9, `dw`.get)
    if (`timeout`.isDefined) size += computeUInt32Size(10, `timeout`.get)
    if (`sloppyQuorum`.isDefined) size += computeBoolSize(11, `sloppyQuorum`.get)
    if (`nVal`.isDefined) size += computeUInt32Size(12, `nVal`.get)

    size
  }

  def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): RpbDelReq = {
    import com.google.protobuf.ExtensionRegistryLite.{ getEmptyRegistry ⇒ _emptyRegistry }
    var __bucket: com.google.protobuf.ByteString = com.google.protobuf.ByteString.EMPTY
    var __key: com.google.protobuf.ByteString = com.google.protobuf.ByteString.EMPTY
    var __rw: Option[Int] = `rw`
    var __vclock: Option[com.google.protobuf.ByteString] = `vclock`
    var __r: Option[Int] = `r`
    var __w: Option[Int] = `w`
    var __pr: Option[Int] = `pr`
    var __pw: Option[Int] = `pw`
    var __dw: Option[Int] = `dw`
    var __timeout: Option[Int] = `timeout`
    var __sloppyQuorum: Option[Boolean] = `sloppyQuorum`
    var __nVal: Option[Int] = `nVal`

      def __newMerged = RpbDelReq(
        __bucket,
        __key,
        __rw,
        __vclock,
        __r,
        __w,
        __pr,
        __pw,
        __dw,
        __timeout,
        __sloppyQuorum,
        __nVal)
    while (true) in.readTag match {
      case 0       ⇒ return __newMerged
      case 10      ⇒ __bucket = in.readBytes()
      case 18      ⇒ __key = in.readBytes()
      case 24      ⇒ __rw = in.readUInt32()
      case 34      ⇒ __vclock = in.readBytes()
      case 40      ⇒ __r = in.readUInt32()
      case 48      ⇒ __w = in.readUInt32()
      case 56      ⇒ __pr = in.readUInt32()
      case 64      ⇒ __pw = in.readUInt32()
      case 72      ⇒ __dw = in.readUInt32()
      case 80      ⇒ __timeout = in.readUInt32()
      case 88      ⇒ __sloppyQuorum = in.readBool()
      case 96      ⇒ __nVal = in.readUInt32()
      case default ⇒ if (!in.skipField(default)) return __newMerged
    }
    null
  }

  def mergeFrom(m: RpbDelReq) = {
    RpbDelReq(
      m.`bucket`,
      m.`key`,
      m.`rw`.orElse(`rw`),
      m.`vclock`.orElse(`vclock`),
      m.`r`.orElse(`r`),
      m.`w`.orElse(`w`),
      m.`pr`.orElse(`pr`),
      m.`pw`.orElse(`pw`),
      m.`dw`.orElse(`dw`),
      m.`timeout`.orElse(`timeout`),
      m.`sloppyQuorum`.orElse(`sloppyQuorum`),
      m.`nVal`.orElse(`nVal`))
  }

  def getDefaultInstanceForType = RpbDelReq.defaultInstance
  def clear = getDefaultInstanceForType
  def isInitialized = true
  def build = this
  def buildPartial = this
  def newBuilderForType = this
  def toBuilder = this
}

object RpbDelReq {
  @reflect.BeanProperty val defaultInstance = new RpbDelReq()

  val BUCKET_FIELD_NUMBER = 1
  val KEY_FIELD_NUMBER = 2
  val RW_FIELD_NUMBER = 3
  val VCLOCK_FIELD_NUMBER = 4
  val R_FIELD_NUMBER = 5
  val W_FIELD_NUMBER = 6
  val PR_FIELD_NUMBER = 7
  val PW_FIELD_NUMBER = 8
  val DW_FIELD_NUMBER = 9
  val TIMEOUT_FIELD_NUMBER = 10
  val SLOPPY_QUORUM_FIELD_NUMBER = 11
  val N_VAL_FIELD_NUMBER = 12

}
final case class RpbListBucketsReq(
  `timeout`: Option[Int] = None,
  `stream`: Option[Boolean] = None) extends com.google.protobuf.GeneratedMessageLite
    with com.google.protobuf.MessageLite.Builder
    with Message[RpbListBucketsReq] {

  def setTimeout(_f: Int) = copy(`timeout` = _f)
  def setStream(_f: Boolean) = copy(`stream` = _f)

  def clearTimeout = copy(`timeout` = None)
  def clearStream = copy(`stream` = None)

  def writeTo(output: com.google.protobuf.CodedOutputStream) {
    if (`timeout`.isDefined) output.writeUInt32(1, `timeout`.get)
    if (`stream`.isDefined) output.writeBool(2, `stream`.get)
  }

  lazy val getSerializedSize = {
    import com.google.protobuf.CodedOutputStream._
    var size = 0
    if (`timeout`.isDefined) size += computeUInt32Size(1, `timeout`.get)
    if (`stream`.isDefined) size += computeBoolSize(2, `stream`.get)

    size
  }

  def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): RpbListBucketsReq = {
    import com.google.protobuf.ExtensionRegistryLite.{ getEmptyRegistry ⇒ _emptyRegistry }
    var __timeout: Option[Int] = `timeout`
    var __stream: Option[Boolean] = `stream`

      def __newMerged = RpbListBucketsReq(
        __timeout,
        __stream)
    while (true) in.readTag match {
      case 0       ⇒ return __newMerged
      case 8       ⇒ __timeout = in.readUInt32()
      case 16      ⇒ __stream = in.readBool()
      case default ⇒ if (!in.skipField(default)) return __newMerged
    }
    null
  }

  def mergeFrom(m: RpbListBucketsReq) = {
    RpbListBucketsReq(
      m.`timeout`.orElse(`timeout`),
      m.`stream`.orElse(`stream`))
  }

  def getDefaultInstanceForType = RpbListBucketsReq.defaultInstance
  def clear = getDefaultInstanceForType
  def isInitialized = true
  def build = this
  def buildPartial = this
  def newBuilderForType = this
  def toBuilder = this
}

object RpbListBucketsReq {
  @reflect.BeanProperty val defaultInstance = new RpbListBucketsReq()

  val TIMEOUT_FIELD_NUMBER = 1
  val STREAM_FIELD_NUMBER = 2

}
final case class RpbListBucketsResp(
  `buckets`: Vector[com.google.protobuf.ByteString] = Vector.empty[com.google.protobuf.ByteString],
  `done`: Option[Boolean] = None) extends com.google.protobuf.GeneratedMessageLite
    with com.google.protobuf.MessageLite.Builder
    with Message[RpbListBucketsResp] {

  def setBuckets(_i: Int, _v: com.google.protobuf.ByteString) = copy(`buckets` = `buckets`.updated(_i, _v))
  def addBuckets(_f: com.google.protobuf.ByteString) = copy(`buckets` = `buckets` :+ _f)
  def addAllBuckets(_f: com.google.protobuf.ByteString*) = copy(`buckets` = `buckets` ++ _f)
  def addAllBuckets(_f: TraversableOnce[com.google.protobuf.ByteString]) = copy(`buckets` = `buckets` ++ _f)
  def setDone(_f: Boolean) = copy(`done` = _f)

  def clearBuckets = copy(`buckets` = Vector.empty[com.google.protobuf.ByteString])
  def clearDone = copy(`done` = None)

  def writeTo(output: com.google.protobuf.CodedOutputStream) {
    for (_v ← `buckets`) output.writeBytes(1, _v)
    if (`done`.isDefined) output.writeBool(2, `done`.get)
  }

  lazy val getSerializedSize = {
    import com.google.protobuf.CodedOutputStream._
    var size = 0
    for (_v ← `buckets`) size += computeBytesSize(1, _v)
    if (`done`.isDefined) size += computeBoolSize(2, `done`.get)

    size
  }

  def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): RpbListBucketsResp = {
    import com.google.protobuf.ExtensionRegistryLite.{ getEmptyRegistry ⇒ _emptyRegistry }
    val __buckets: collection.mutable.Buffer[com.google.protobuf.ByteString] = `buckets`.toBuffer
    var __done: Option[Boolean] = `done`

      def __newMerged = RpbListBucketsResp(
        Vector(__buckets: _*),
        __done)
    while (true) in.readTag match {
      case 0       ⇒ return __newMerged
      case 10      ⇒ __buckets += in.readBytes()
      case 16      ⇒ __done = in.readBool()
      case default ⇒ if (!in.skipField(default)) return __newMerged
    }
    null
  }

  def mergeFrom(m: RpbListBucketsResp) = {
    RpbListBucketsResp(
      `buckets` ++ m.`buckets`,
      m.`done`.orElse(`done`))
  }

  def getDefaultInstanceForType = RpbListBucketsResp.defaultInstance
  def clear = getDefaultInstanceForType
  def isInitialized = true
  def build = this
  def buildPartial = this
  def newBuilderForType = this
  def toBuilder = this
}

object RpbListBucketsResp {
  @reflect.BeanProperty val defaultInstance = new RpbListBucketsResp()

  val BUCKETS_FIELD_NUMBER = 1
  val DONE_FIELD_NUMBER = 2

}
final case class RpbListKeysReq(
  `bucket`: com.google.protobuf.ByteString = com.google.protobuf.ByteString.EMPTY,
  `timeout`: Option[Int] = None) extends com.google.protobuf.GeneratedMessageLite
    with com.google.protobuf.MessageLite.Builder
    with Message[RpbListKeysReq] {

  def setTimeout(_f: Int) = copy(`timeout` = _f)

  def clearTimeout = copy(`timeout` = None)

  def writeTo(output: com.google.protobuf.CodedOutputStream) {
    output.writeBytes(1, `bucket`)
    if (`timeout`.isDefined) output.writeUInt32(2, `timeout`.get)
  }

  lazy val getSerializedSize = {
    import com.google.protobuf.CodedOutputStream._
    var size = 0
    size += computeBytesSize(1, `bucket`)
    if (`timeout`.isDefined) size += computeUInt32Size(2, `timeout`.get)

    size
  }

  def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): RpbListKeysReq = {
    import com.google.protobuf.ExtensionRegistryLite.{ getEmptyRegistry ⇒ _emptyRegistry }
    var __bucket: com.google.protobuf.ByteString = com.google.protobuf.ByteString.EMPTY
    var __timeout: Option[Int] = `timeout`

      def __newMerged = RpbListKeysReq(
        __bucket,
        __timeout)
    while (true) in.readTag match {
      case 0       ⇒ return __newMerged
      case 10      ⇒ __bucket = in.readBytes()
      case 16      ⇒ __timeout = in.readUInt32()
      case default ⇒ if (!in.skipField(default)) return __newMerged
    }
    null
  }

  def mergeFrom(m: RpbListKeysReq) = {
    RpbListKeysReq(
      m.`bucket`,
      m.`timeout`.orElse(`timeout`))
  }

  def getDefaultInstanceForType = RpbListKeysReq.defaultInstance
  def clear = getDefaultInstanceForType
  def isInitialized = true
  def build = this
  def buildPartial = this
  def newBuilderForType = this
  def toBuilder = this
}

object RpbListKeysReq {
  @reflect.BeanProperty val defaultInstance = new RpbListKeysReq()

  val BUCKET_FIELD_NUMBER = 1
  val TIMEOUT_FIELD_NUMBER = 2

}
final case class RpbListKeysResp(
  `keys`: Vector[com.google.protobuf.ByteString] = Vector.empty[com.google.protobuf.ByteString],
  `done`: Option[Boolean] = None) extends com.google.protobuf.GeneratedMessageLite
    with com.google.protobuf.MessageLite.Builder
    with Message[RpbListKeysResp] {

  def setKeys(_i: Int, _v: com.google.protobuf.ByteString) = copy(`keys` = `keys`.updated(_i, _v))
  def addKeys(_f: com.google.protobuf.ByteString) = copy(`keys` = `keys` :+ _f)
  def addAllKeys(_f: com.google.protobuf.ByteString*) = copy(`keys` = `keys` ++ _f)
  def addAllKeys(_f: TraversableOnce[com.google.protobuf.ByteString]) = copy(`keys` = `keys` ++ _f)
  def setDone(_f: Boolean) = copy(`done` = _f)

  def clearKeys = copy(`keys` = Vector.empty[com.google.protobuf.ByteString])
  def clearDone = copy(`done` = None)

  def writeTo(output: com.google.protobuf.CodedOutputStream) {
    for (_v ← `keys`) output.writeBytes(1, _v)
    if (`done`.isDefined) output.writeBool(2, `done`.get)
  }

  lazy val getSerializedSize = {
    import com.google.protobuf.CodedOutputStream._
    var size = 0
    for (_v ← `keys`) size += computeBytesSize(1, _v)
    if (`done`.isDefined) size += computeBoolSize(2, `done`.get)

    size
  }

  def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): RpbListKeysResp = {
    import com.google.protobuf.ExtensionRegistryLite.{ getEmptyRegistry ⇒ _emptyRegistry }
    val __keys: collection.mutable.Buffer[com.google.protobuf.ByteString] = `keys`.toBuffer
    var __done: Option[Boolean] = `done`

      def __newMerged = RpbListKeysResp(
        Vector(__keys: _*),
        __done)
    while (true) in.readTag match {
      case 0       ⇒ return __newMerged
      case 10      ⇒ __keys += in.readBytes()
      case 16      ⇒ __done = in.readBool()
      case default ⇒ if (!in.skipField(default)) return __newMerged
    }
    null
  }

  def mergeFrom(m: RpbListKeysResp) = {
    RpbListKeysResp(
      `keys` ++ m.`keys`,
      m.`done`.orElse(`done`))
  }

  def getDefaultInstanceForType = RpbListKeysResp.defaultInstance
  def clear = getDefaultInstanceForType
  def isInitialized = true
  def build = this
  def buildPartial = this
  def newBuilderForType = this
  def toBuilder = this
}

object RpbListKeysResp {
  @reflect.BeanProperty val defaultInstance = new RpbListKeysResp()

  val KEYS_FIELD_NUMBER = 1
  val DONE_FIELD_NUMBER = 2

}
final case class RpbMapRedReq(
  `request`: com.google.protobuf.ByteString = com.google.protobuf.ByteString.EMPTY,
  `contentType`: com.google.protobuf.ByteString = com.google.protobuf.ByteString.EMPTY) extends com.google.protobuf.GeneratedMessageLite
    with com.google.protobuf.MessageLite.Builder
    with Message[RpbMapRedReq] {

  def writeTo(output: com.google.protobuf.CodedOutputStream) {
    output.writeBytes(1, `request`)
    output.writeBytes(2, `contentType`)
  }

  lazy val getSerializedSize = {
    import com.google.protobuf.CodedOutputStream._
    var size = 0
    size += computeBytesSize(1, `request`)
    size += computeBytesSize(2, `contentType`)

    size
  }

  def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): RpbMapRedReq = {
    import com.google.protobuf.ExtensionRegistryLite.{ getEmptyRegistry ⇒ _emptyRegistry }
    var __request: com.google.protobuf.ByteString = com.google.protobuf.ByteString.EMPTY
    var __contentType: com.google.protobuf.ByteString = com.google.protobuf.ByteString.EMPTY

      def __newMerged = RpbMapRedReq(
        __request,
        __contentType)
    while (true) in.readTag match {
      case 0       ⇒ return __newMerged
      case 10      ⇒ __request = in.readBytes()
      case 18      ⇒ __contentType = in.readBytes()
      case default ⇒ if (!in.skipField(default)) return __newMerged
    }
    null
  }

  def mergeFrom(m: RpbMapRedReq) = {
    RpbMapRedReq(
      m.`request`,
      m.`contentType`)
  }

  def getDefaultInstanceForType = RpbMapRedReq.defaultInstance
  def clear = getDefaultInstanceForType
  def isInitialized = true
  def build = this
  def buildPartial = this
  def newBuilderForType = this
  def toBuilder = this
}

object RpbMapRedReq {
  @reflect.BeanProperty val defaultInstance = new RpbMapRedReq()

  val REQUEST_FIELD_NUMBER = 1
  val CONTENT_TYPE_FIELD_NUMBER = 2

}
final case class RpbMapRedResp(
  `phase`: Option[Int] = None,
  `response`: Option[com.google.protobuf.ByteString] = None,
  `done`: Option[Boolean] = None) extends com.google.protobuf.GeneratedMessageLite
    with com.google.protobuf.MessageLite.Builder
    with Message[RpbMapRedResp] {

  def setPhase(_f: Int) = copy(`phase` = _f)
  def setResponse(_f: com.google.protobuf.ByteString) = copy(`response` = _f)
  def setDone(_f: Boolean) = copy(`done` = _f)

  def clearPhase = copy(`phase` = None)
  def clearResponse = copy(`response` = None)
  def clearDone = copy(`done` = None)

  def writeTo(output: com.google.protobuf.CodedOutputStream) {
    if (`phase`.isDefined) output.writeUInt32(1, `phase`.get)
    if (`response`.isDefined) output.writeBytes(2, `response`.get)
    if (`done`.isDefined) output.writeBool(3, `done`.get)
  }

  lazy val getSerializedSize = {
    import com.google.protobuf.CodedOutputStream._
    var size = 0
    if (`phase`.isDefined) size += computeUInt32Size(1, `phase`.get)
    if (`response`.isDefined) size += computeBytesSize(2, `response`.get)
    if (`done`.isDefined) size += computeBoolSize(3, `done`.get)

    size
  }

  def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): RpbMapRedResp = {
    import com.google.protobuf.ExtensionRegistryLite.{ getEmptyRegistry ⇒ _emptyRegistry }
    var __phase: Option[Int] = `phase`
    var __response: Option[com.google.protobuf.ByteString] = `response`
    var __done: Option[Boolean] = `done`

      def __newMerged = RpbMapRedResp(
        __phase,
        __response,
        __done)
    while (true) in.readTag match {
      case 0       ⇒ return __newMerged
      case 8       ⇒ __phase = in.readUInt32()
      case 18      ⇒ __response = in.readBytes()
      case 24      ⇒ __done = in.readBool()
      case default ⇒ if (!in.skipField(default)) return __newMerged
    }
    null
  }

  def mergeFrom(m: RpbMapRedResp) = {
    RpbMapRedResp(
      m.`phase`.orElse(`phase`),
      m.`response`.orElse(`response`),
      m.`done`.orElse(`done`))
  }

  def getDefaultInstanceForType = RpbMapRedResp.defaultInstance
  def clear = getDefaultInstanceForType
  def isInitialized = true
  def build = this
  def buildPartial = this
  def newBuilderForType = this
  def toBuilder = this
}

object RpbMapRedResp {
  @reflect.BeanProperty val defaultInstance = new RpbMapRedResp()

  val PHASE_FIELD_NUMBER = 1
  val RESPONSE_FIELD_NUMBER = 2
  val DONE_FIELD_NUMBER = 3

}
final case class RpbIndexReq(
  `bucket`: com.google.protobuf.ByteString = com.google.protobuf.ByteString.EMPTY,
  `index`: com.google.protobuf.ByteString = com.google.protobuf.ByteString.EMPTY,
  `qtype`: RpbIndexReq.IndexQueryType.EnumVal = RpbIndexReq.IndexQueryType._UNINITIALIZED,
  `key`: Option[com.google.protobuf.ByteString] = None,
  `rangeMin`: Option[com.google.protobuf.ByteString] = None,
  `rangeMax`: Option[com.google.protobuf.ByteString] = None,
  `returnTerms`: Option[Boolean] = None,
  `stream`: Option[Boolean] = None,
  `maxResults`: Option[Int] = None,
  `continuation`: Option[com.google.protobuf.ByteString] = None) extends com.google.protobuf.GeneratedMessageLite
    with com.google.protobuf.MessageLite.Builder
    with Message[RpbIndexReq] {

  def setKey(_f: com.google.protobuf.ByteString) = copy(`key` = _f)
  def setRangeMin(_f: com.google.protobuf.ByteString) = copy(`rangeMin` = _f)
  def setRangeMax(_f: com.google.protobuf.ByteString) = copy(`rangeMax` = _f)
  def setReturnTerms(_f: Boolean) = copy(`returnTerms` = _f)
  def setStream(_f: Boolean) = copy(`stream` = _f)
  def setMaxResults(_f: Int) = copy(`maxResults` = _f)
  def setContinuation(_f: com.google.protobuf.ByteString) = copy(`continuation` = _f)

  def clearKey = copy(`key` = None)
  def clearRangeMin = copy(`rangeMin` = None)
  def clearRangeMax = copy(`rangeMax` = None)
  def clearReturnTerms = copy(`returnTerms` = None)
  def clearStream = copy(`stream` = None)
  def clearMaxResults = copy(`maxResults` = None)
  def clearContinuation = copy(`continuation` = None)

  def writeTo(output: com.google.protobuf.CodedOutputStream) {
    output.writeBytes(1, `bucket`)
    output.writeBytes(2, `index`)
    output.writeEnum(3, `qtype`)
    if (`key`.isDefined) output.writeBytes(4, `key`.get)
    if (`rangeMin`.isDefined) output.writeBytes(5, `rangeMin`.get)
    if (`rangeMax`.isDefined) output.writeBytes(6, `rangeMax`.get)
    if (`returnTerms`.isDefined) output.writeBool(7, `returnTerms`.get)
    if (`stream`.isDefined) output.writeBool(8, `stream`.get)
    if (`maxResults`.isDefined) output.writeUInt32(9, `maxResults`.get)
    if (`continuation`.isDefined) output.writeBytes(10, `continuation`.get)
  }

  lazy val getSerializedSize = {
    import com.google.protobuf.CodedOutputStream._
    var size = 0
    size += computeBytesSize(1, `bucket`)
    size += computeBytesSize(2, `index`)
    size += computeEnumSize(3, `qtype`)
    if (`key`.isDefined) size += computeBytesSize(4, `key`.get)
    if (`rangeMin`.isDefined) size += computeBytesSize(5, `rangeMin`.get)
    if (`rangeMax`.isDefined) size += computeBytesSize(6, `rangeMax`.get)
    if (`returnTerms`.isDefined) size += computeBoolSize(7, `returnTerms`.get)
    if (`stream`.isDefined) size += computeBoolSize(8, `stream`.get)
    if (`maxResults`.isDefined) size += computeUInt32Size(9, `maxResults`.get)
    if (`continuation`.isDefined) size += computeBytesSize(10, `continuation`.get)

    size
  }

  def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): RpbIndexReq = {
    import com.google.protobuf.ExtensionRegistryLite.{ getEmptyRegistry ⇒ _emptyRegistry }
    var __bucket: com.google.protobuf.ByteString = com.google.protobuf.ByteString.EMPTY
    var __index: com.google.protobuf.ByteString = com.google.protobuf.ByteString.EMPTY
    var __qtype: RpbIndexReq.IndexQueryType.EnumVal = RpbIndexReq.IndexQueryType._UNINITIALIZED
    var __key: Option[com.google.protobuf.ByteString] = `key`
    var __rangeMin: Option[com.google.protobuf.ByteString] = `rangeMin`
    var __rangeMax: Option[com.google.protobuf.ByteString] = `rangeMax`
    var __returnTerms: Option[Boolean] = `returnTerms`
    var __stream: Option[Boolean] = `stream`
    var __maxResults: Option[Int] = `maxResults`
    var __continuation: Option[com.google.protobuf.ByteString] = `continuation`

      def __newMerged = RpbIndexReq(
        __bucket,
        __index,
        __qtype,
        __key,
        __rangeMin,
        __rangeMax,
        __returnTerms,
        __stream,
        __maxResults,
        __continuation)
    while (true) in.readTag match {
      case 0       ⇒ return __newMerged
      case 10      ⇒ __bucket = in.readBytes()
      case 18      ⇒ __index = in.readBytes()
      case 24      ⇒ __qtype = RpbIndexReq.IndexQueryType.valueOf(in.readEnum())
      case 34      ⇒ __key = in.readBytes()
      case 42      ⇒ __rangeMin = in.readBytes()
      case 50      ⇒ __rangeMax = in.readBytes()
      case 56      ⇒ __returnTerms = in.readBool()
      case 64      ⇒ __stream = in.readBool()
      case 72      ⇒ __maxResults = in.readUInt32()
      case 82      ⇒ __continuation = in.readBytes()
      case default ⇒ if (!in.skipField(default)) return __newMerged
    }
    null
  }

  def mergeFrom(m: RpbIndexReq) = {
    RpbIndexReq(
      m.`bucket`,
      m.`index`,
      m.`qtype`,
      m.`key`.orElse(`key`),
      m.`rangeMin`.orElse(`rangeMin`),
      m.`rangeMax`.orElse(`rangeMax`),
      m.`returnTerms`.orElse(`returnTerms`),
      m.`stream`.orElse(`stream`),
      m.`maxResults`.orElse(`maxResults`),
      m.`continuation`.orElse(`continuation`))
  }

  def getDefaultInstanceForType = RpbIndexReq.defaultInstance
  def clear = getDefaultInstanceForType
  def isInitialized = true
  def build = this
  def buildPartial = this
  def newBuilderForType = this
  def toBuilder = this
}

object RpbIndexReq {
  @reflect.BeanProperty val defaultInstance = new RpbIndexReq()

  val BUCKET_FIELD_NUMBER = 1
  val INDEX_FIELD_NUMBER = 2
  val QTYPE_FIELD_NUMBER = 3
  val KEY_FIELD_NUMBER = 4
  val RANGE_MIN_FIELD_NUMBER = 5
  val RANGE_MAX_FIELD_NUMBER = 6
  val RETURN_TERMS_FIELD_NUMBER = 7
  val STREAM_FIELD_NUMBER = 8
  val MAX_RESULTS_FIELD_NUMBER = 9
  val CONTINUATION_FIELD_NUMBER = 10

  object IndexQueryType extends Enum {
    sealed trait EnumVal extends Value
    val _UNINITIALIZED = new EnumVal { val name = "UNINITIALIZED ENUM VALUE"; val id = -1 }

    val eq = new EnumVal { val name = "eq"; val id = 0 }
    val range = new EnumVal { val name = "range"; val id = 1 }

    val eq_VALUE = 0
    val range_VALUE = 1

    def valueOf(id: Int) = id match {
      case 0        ⇒ eq
      case 1        ⇒ range
      case _default ⇒ throw new UnknownEnumException(_default)
    }
    val internalGetValueMap = new com.google.protobuf.Internal.EnumLiteMap[EnumVal] {
      def findValueByNumber(id: Int): EnumVal = valueOf(id)
    }
  }

}
final case class RpbIndexResp(
  `keys`: Vector[com.google.protobuf.ByteString] = Vector.empty[com.google.protobuf.ByteString],
  `results`: Vector[RpbPair] = Vector.empty[RpbPair],
  `continuation`: Option[com.google.protobuf.ByteString] = None,
  `done`: Option[Boolean] = None) extends com.google.protobuf.GeneratedMessageLite
    with com.google.protobuf.MessageLite.Builder
    with Message[RpbIndexResp] {

  def setKeys(_i: Int, _v: com.google.protobuf.ByteString) = copy(`keys` = `keys`.updated(_i, _v))
  def addKeys(_f: com.google.protobuf.ByteString) = copy(`keys` = `keys` :+ _f)
  def addAllKeys(_f: com.google.protobuf.ByteString*) = copy(`keys` = `keys` ++ _f)
  def addAllKeys(_f: TraversableOnce[com.google.protobuf.ByteString]) = copy(`keys` = `keys` ++ _f)
  def setResults(_i: Int, _v: RpbPair) = copy(`results` = `results`.updated(_i, _v))
  def addResults(_f: RpbPair) = copy(`results` = `results` :+ _f)
  def addAllResults(_f: RpbPair*) = copy(`results` = `results` ++ _f)
  def addAllResults(_f: TraversableOnce[RpbPair]) = copy(`results` = `results` ++ _f)
  def setContinuation(_f: com.google.protobuf.ByteString) = copy(`continuation` = _f)
  def setDone(_f: Boolean) = copy(`done` = _f)

  def clearKeys = copy(`keys` = Vector.empty[com.google.protobuf.ByteString])
  def clearResults = copy(`results` = Vector.empty[RpbPair])
  def clearContinuation = copy(`continuation` = None)
  def clearDone = copy(`done` = None)

  def writeTo(output: com.google.protobuf.CodedOutputStream) {
    for (_v ← `keys`) output.writeBytes(1, _v)
    for (_v ← `results`) output.writeMessage(2, _v)
    if (`continuation`.isDefined) output.writeBytes(3, `continuation`.get)
    if (`done`.isDefined) output.writeBool(4, `done`.get)
  }

  lazy val getSerializedSize = {
    import com.google.protobuf.CodedOutputStream._
    var size = 0
    for (_v ← `keys`) size += computeBytesSize(1, _v)
    for (_v ← `results`) size += computeMessageSize(2, _v)
    if (`continuation`.isDefined) size += computeBytesSize(3, `continuation`.get)
    if (`done`.isDefined) size += computeBoolSize(4, `done`.get)

    size
  }

  def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): RpbIndexResp = {
    import com.google.protobuf.ExtensionRegistryLite.{ getEmptyRegistry ⇒ _emptyRegistry }
    val __keys: collection.mutable.Buffer[com.google.protobuf.ByteString] = `keys`.toBuffer
    val __results: collection.mutable.Buffer[RpbPair] = `results`.toBuffer
    var __continuation: Option[com.google.protobuf.ByteString] = `continuation`
    var __done: Option[Boolean] = `done`

      def __newMerged = RpbIndexResp(
        Vector(__keys: _*),
        Vector(__results: _*),
        __continuation,
        __done)
    while (true) in.readTag match {
      case 0       ⇒ return __newMerged
      case 10      ⇒ __keys += in.readBytes()
      case 18      ⇒ __results += readMessage[RpbPair](in, RpbPair.defaultInstance, _emptyRegistry)
      case 26      ⇒ __continuation = in.readBytes()
      case 32      ⇒ __done = in.readBool()
      case default ⇒ if (!in.skipField(default)) return __newMerged
    }
    null
  }

  def mergeFrom(m: RpbIndexResp) = {
    RpbIndexResp(
      `keys` ++ m.`keys`,
      `results` ++ m.`results`,
      m.`continuation`.orElse(`continuation`),
      m.`done`.orElse(`done`))
  }

  def getDefaultInstanceForType = RpbIndexResp.defaultInstance
  def clear = getDefaultInstanceForType
  def isInitialized = true
  def build = this
  def buildPartial = this
  def newBuilderForType = this
  def toBuilder = this
}

object RpbIndexResp {
  @reflect.BeanProperty val defaultInstance = new RpbIndexResp()

  val KEYS_FIELD_NUMBER = 1
  val RESULTS_FIELD_NUMBER = 2
  val CONTINUATION_FIELD_NUMBER = 3
  val DONE_FIELD_NUMBER = 4

}
final case class RpbCSBucketReq(
  `bucket`: com.google.protobuf.ByteString = com.google.protobuf.ByteString.EMPTY,
  `startKey`: com.google.protobuf.ByteString = com.google.protobuf.ByteString.EMPTY,
  `endKey`: Option[com.google.protobuf.ByteString] = None,
  `startIncl`: Option[Boolean] = Some(true),
  `endIncl`: Option[Boolean] = Some(false),
  `continuation`: Option[com.google.protobuf.ByteString] = None,
  `maxResults`: Option[Int] = None) extends com.google.protobuf.GeneratedMessageLite
    with com.google.protobuf.MessageLite.Builder
    with Message[RpbCSBucketReq] {

  def setEndKey(_f: com.google.protobuf.ByteString) = copy(`endKey` = _f)
  def setStartIncl(_f: Boolean) = copy(`startIncl` = _f)
  def setEndIncl(_f: Boolean) = copy(`endIncl` = _f)
  def setContinuation(_f: com.google.protobuf.ByteString) = copy(`continuation` = _f)
  def setMaxResults(_f: Int) = copy(`maxResults` = _f)

  def clearEndKey = copy(`endKey` = None)
  def clearStartIncl = copy(`startIncl` = None)
  def clearEndIncl = copy(`endIncl` = None)
  def clearContinuation = copy(`continuation` = None)
  def clearMaxResults = copy(`maxResults` = None)

  def writeTo(output: com.google.protobuf.CodedOutputStream) {
    output.writeBytes(1, `bucket`)
    output.writeBytes(2, `startKey`)
    if (`endKey`.isDefined) output.writeBytes(3, `endKey`.get)
    if (`startIncl`.isDefined) output.writeBool(4, `startIncl`.get)
    if (`endIncl`.isDefined) output.writeBool(5, `endIncl`.get)
    if (`continuation`.isDefined) output.writeBytes(6, `continuation`.get)
    if (`maxResults`.isDefined) output.writeUInt32(7, `maxResults`.get)
  }

  lazy val getSerializedSize = {
    import com.google.protobuf.CodedOutputStream._
    var size = 0
    size += computeBytesSize(1, `bucket`)
    size += computeBytesSize(2, `startKey`)
    if (`endKey`.isDefined) size += computeBytesSize(3, `endKey`.get)
    if (`startIncl`.isDefined) size += computeBoolSize(4, `startIncl`.get)
    if (`endIncl`.isDefined) size += computeBoolSize(5, `endIncl`.get)
    if (`continuation`.isDefined) size += computeBytesSize(6, `continuation`.get)
    if (`maxResults`.isDefined) size += computeUInt32Size(7, `maxResults`.get)

    size
  }

  def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): RpbCSBucketReq = {
    import com.google.protobuf.ExtensionRegistryLite.{ getEmptyRegistry ⇒ _emptyRegistry }
    var __bucket: com.google.protobuf.ByteString = com.google.protobuf.ByteString.EMPTY
    var __startKey: com.google.protobuf.ByteString = com.google.protobuf.ByteString.EMPTY
    var __endKey: Option[com.google.protobuf.ByteString] = `endKey`
    var __startIncl: Option[Boolean] = `startIncl`
    var __endIncl: Option[Boolean] = `endIncl`
    var __continuation: Option[com.google.protobuf.ByteString] = `continuation`
    var __maxResults: Option[Int] = `maxResults`

      def __newMerged = RpbCSBucketReq(
        __bucket,
        __startKey,
        __endKey,
        __startIncl,
        __endIncl,
        __continuation,
        __maxResults)
    while (true) in.readTag match {
      case 0       ⇒ return __newMerged
      case 10      ⇒ __bucket = in.readBytes()
      case 18      ⇒ __startKey = in.readBytes()
      case 26      ⇒ __endKey = in.readBytes()
      case 32      ⇒ __startIncl = in.readBool()
      case 40      ⇒ __endIncl = in.readBool()
      case 50      ⇒ __continuation = in.readBytes()
      case 56      ⇒ __maxResults = in.readUInt32()
      case default ⇒ if (!in.skipField(default)) return __newMerged
    }
    null
  }

  def mergeFrom(m: RpbCSBucketReq) = {
    RpbCSBucketReq(
      m.`bucket`,
      m.`startKey`,
      m.`endKey`.orElse(`endKey`),
      m.`startIncl`.orElse(`startIncl`),
      m.`endIncl`.orElse(`endIncl`),
      m.`continuation`.orElse(`continuation`),
      m.`maxResults`.orElse(`maxResults`))
  }

  def getDefaultInstanceForType = RpbCSBucketReq.defaultInstance
  def clear = getDefaultInstanceForType
  def isInitialized = true
  def build = this
  def buildPartial = this
  def newBuilderForType = this
  def toBuilder = this
}

object RpbCSBucketReq {
  @reflect.BeanProperty val defaultInstance = new RpbCSBucketReq()

  val BUCKET_FIELD_NUMBER = 1
  val START_KEY_FIELD_NUMBER = 2
  val END_KEY_FIELD_NUMBER = 3
  val START_INCL_FIELD_NUMBER = 4
  val END_INCL_FIELD_NUMBER = 5
  val CONTINUATION_FIELD_NUMBER = 6
  val MAX_RESULTS_FIELD_NUMBER = 7

}
final case class RpbCSBucketResp(
  `objects`: Vector[RpbIndexObject] = Vector.empty[RpbIndexObject],
  `continuation`: Option[com.google.protobuf.ByteString] = None,
  `done`: Option[Boolean] = None) extends com.google.protobuf.GeneratedMessageLite
    with com.google.protobuf.MessageLite.Builder
    with Message[RpbCSBucketResp] {

  def setObjects(_i: Int, _v: RpbIndexObject) = copy(`objects` = `objects`.updated(_i, _v))
  def addObjects(_f: RpbIndexObject) = copy(`objects` = `objects` :+ _f)
  def addAllObjects(_f: RpbIndexObject*) = copy(`objects` = `objects` ++ _f)
  def addAllObjects(_f: TraversableOnce[RpbIndexObject]) = copy(`objects` = `objects` ++ _f)
  def setContinuation(_f: com.google.protobuf.ByteString) = copy(`continuation` = _f)
  def setDone(_f: Boolean) = copy(`done` = _f)

  def clearObjects = copy(`objects` = Vector.empty[RpbIndexObject])
  def clearContinuation = copy(`continuation` = None)
  def clearDone = copy(`done` = None)

  def writeTo(output: com.google.protobuf.CodedOutputStream) {
    for (_v ← `objects`) output.writeMessage(1, _v)
    if (`continuation`.isDefined) output.writeBytes(2, `continuation`.get)
    if (`done`.isDefined) output.writeBool(3, `done`.get)
  }

  lazy val getSerializedSize = {
    import com.google.protobuf.CodedOutputStream._
    var size = 0
    for (_v ← `objects`) size += computeMessageSize(1, _v)
    if (`continuation`.isDefined) size += computeBytesSize(2, `continuation`.get)
    if (`done`.isDefined) size += computeBoolSize(3, `done`.get)

    size
  }

  def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): RpbCSBucketResp = {
    import com.google.protobuf.ExtensionRegistryLite.{ getEmptyRegistry ⇒ _emptyRegistry }
    val __objects: collection.mutable.Buffer[RpbIndexObject] = `objects`.toBuffer
    var __continuation: Option[com.google.protobuf.ByteString] = `continuation`
    var __done: Option[Boolean] = `done`

      def __newMerged = RpbCSBucketResp(
        Vector(__objects: _*),
        __continuation,
        __done)
    while (true) in.readTag match {
      case 0       ⇒ return __newMerged
      case 10      ⇒ __objects += readMessage[RpbIndexObject](in, RpbIndexObject.defaultInstance, _emptyRegistry)
      case 18      ⇒ __continuation = in.readBytes()
      case 24      ⇒ __done = in.readBool()
      case default ⇒ if (!in.skipField(default)) return __newMerged
    }
    null
  }

  def mergeFrom(m: RpbCSBucketResp) = {
    RpbCSBucketResp(
      `objects` ++ m.`objects`,
      m.`continuation`.orElse(`continuation`),
      m.`done`.orElse(`done`))
  }

  def getDefaultInstanceForType = RpbCSBucketResp.defaultInstance
  def clear = getDefaultInstanceForType
  def isInitialized = true
  def build = this
  def buildPartial = this
  def newBuilderForType = this
  def toBuilder = this
}

object RpbCSBucketResp {
  @reflect.BeanProperty val defaultInstance = new RpbCSBucketResp()

  val OBJECTS_FIELD_NUMBER = 1
  val CONTINUATION_FIELD_NUMBER = 2
  val DONE_FIELD_NUMBER = 3

}
final case class RpbIndexObject(
  `key`: com.google.protobuf.ByteString = com.google.protobuf.ByteString.EMPTY,
  `object`: RpbGetResp = RpbGetResp.defaultInstance) extends com.google.protobuf.GeneratedMessageLite
    with com.google.protobuf.MessageLite.Builder
    with Message[RpbIndexObject] {

  def writeTo(output: com.google.protobuf.CodedOutputStream) {
    output.writeBytes(1, `key`)
    output.writeMessage(2, `object`)
  }

  lazy val getSerializedSize = {
    import com.google.protobuf.CodedOutputStream._
    var size = 0
    size += computeBytesSize(1, `key`)
    size += computeMessageSize(2, `object`)

    size
  }

  def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): RpbIndexObject = {
    import com.google.protobuf.ExtensionRegistryLite.{ getEmptyRegistry ⇒ _emptyRegistry }
    var __key: com.google.protobuf.ByteString = com.google.protobuf.ByteString.EMPTY
    var __object: RpbGetResp = RpbGetResp.defaultInstance

      def __newMerged = RpbIndexObject(
        __key,
        __object)
    while (true) in.readTag match {
      case 0       ⇒ return __newMerged
      case 10      ⇒ __key = in.readBytes()
      case 18      ⇒ __object = readMessage[RpbGetResp](in, __object, _emptyRegistry)
      case default ⇒ if (!in.skipField(default)) return __newMerged
    }
    null
  }

  def mergeFrom(m: RpbIndexObject) = {
    RpbIndexObject(
      m.`key`,
      m.`object`)
  }

  def getDefaultInstanceForType = RpbIndexObject.defaultInstance
  def clear = getDefaultInstanceForType
  def isInitialized = true
  def build = this
  def buildPartial = this
  def newBuilderForType = this
  def toBuilder = this
}

object RpbIndexObject {
  @reflect.BeanProperty val defaultInstance = new RpbIndexObject()

  val KEY_FIELD_NUMBER = 1
  val OBJECT_FIELD_NUMBER = 2

}
final case class RpbContent(
  `value`: com.google.protobuf.ByteString = com.google.protobuf.ByteString.EMPTY,
  `contentType`: Option[com.google.protobuf.ByteString] = None,
  `charset`: Option[com.google.protobuf.ByteString] = None,
  `contentEncoding`: Option[com.google.protobuf.ByteString] = None,
  `vtag`: Option[com.google.protobuf.ByteString] = None,
  `links`: Vector[RpbLink] = Vector.empty[RpbLink],
  `lastMod`: Option[Int] = None,
  `lastModUsecs`: Option[Int] = None,
  `usermeta`: Vector[RpbPair] = Vector.empty[RpbPair],
  `indexes`: Vector[RpbPair] = Vector.empty[RpbPair],
  `deleted`: Option[Boolean] = None) extends com.google.protobuf.GeneratedMessageLite
    with com.google.protobuf.MessageLite.Builder
    with Message[RpbContent] {

  def setContentType(_f: com.google.protobuf.ByteString) = copy(`contentType` = _f)
  def setCharset(_f: com.google.protobuf.ByteString) = copy(`charset` = _f)
  def setContentEncoding(_f: com.google.protobuf.ByteString) = copy(`contentEncoding` = _f)
  def setVtag(_f: com.google.protobuf.ByteString) = copy(`vtag` = _f)
  def setLinks(_i: Int, _v: RpbLink) = copy(`links` = `links`.updated(_i, _v))
  def addLinks(_f: RpbLink) = copy(`links` = `links` :+ _f)
  def addAllLinks(_f: RpbLink*) = copy(`links` = `links` ++ _f)
  def addAllLinks(_f: TraversableOnce[RpbLink]) = copy(`links` = `links` ++ _f)
  def setLastMod(_f: Int) = copy(`lastMod` = _f)
  def setLastModUsecs(_f: Int) = copy(`lastModUsecs` = _f)
  def setUsermeta(_i: Int, _v: RpbPair) = copy(`usermeta` = `usermeta`.updated(_i, _v))
  def addUsermeta(_f: RpbPair) = copy(`usermeta` = `usermeta` :+ _f)
  def addAllUsermeta(_f: RpbPair*) = copy(`usermeta` = `usermeta` ++ _f)
  def addAllUsermeta(_f: TraversableOnce[RpbPair]) = copy(`usermeta` = `usermeta` ++ _f)
  def setIndexes(_i: Int, _v: RpbPair) = copy(`indexes` = `indexes`.updated(_i, _v))
  def addIndexes(_f: RpbPair) = copy(`indexes` = `indexes` :+ _f)
  def addAllIndexes(_f: RpbPair*) = copy(`indexes` = `indexes` ++ _f)
  def addAllIndexes(_f: TraversableOnce[RpbPair]) = copy(`indexes` = `indexes` ++ _f)
  def setDeleted(_f: Boolean) = copy(`deleted` = _f)

  def clearContentType = copy(`contentType` = None)
  def clearCharset = copy(`charset` = None)
  def clearContentEncoding = copy(`contentEncoding` = None)
  def clearVtag = copy(`vtag` = None)
  def clearLinks = copy(`links` = Vector.empty[RpbLink])
  def clearLastMod = copy(`lastMod` = None)
  def clearLastModUsecs = copy(`lastModUsecs` = None)
  def clearUsermeta = copy(`usermeta` = Vector.empty[RpbPair])
  def clearIndexes = copy(`indexes` = Vector.empty[RpbPair])
  def clearDeleted = copy(`deleted` = None)

  def writeTo(output: com.google.protobuf.CodedOutputStream) {
    output.writeBytes(1, `value`)
    if (`contentType`.isDefined) output.writeBytes(2, `contentType`.get)
    if (`charset`.isDefined) output.writeBytes(3, `charset`.get)
    if (`contentEncoding`.isDefined) output.writeBytes(4, `contentEncoding`.get)
    if (`vtag`.isDefined) output.writeBytes(5, `vtag`.get)
    for (_v ← `links`) output.writeMessage(6, _v)
    if (`lastMod`.isDefined) output.writeUInt32(7, `lastMod`.get)
    if (`lastModUsecs`.isDefined) output.writeUInt32(8, `lastModUsecs`.get)
    for (_v ← `usermeta`) output.writeMessage(9, _v)
    for (_v ← `indexes`) output.writeMessage(10, _v)
    if (`deleted`.isDefined) output.writeBool(11, `deleted`.get)
  }

  lazy val getSerializedSize = {
    import com.google.protobuf.CodedOutputStream._
    var size = 0
    size += computeBytesSize(1, `value`)
    if (`contentType`.isDefined) size += computeBytesSize(2, `contentType`.get)
    if (`charset`.isDefined) size += computeBytesSize(3, `charset`.get)
    if (`contentEncoding`.isDefined) size += computeBytesSize(4, `contentEncoding`.get)
    if (`vtag`.isDefined) size += computeBytesSize(5, `vtag`.get)
    for (_v ← `links`) size += computeMessageSize(6, _v)
    if (`lastMod`.isDefined) size += computeUInt32Size(7, `lastMod`.get)
    if (`lastModUsecs`.isDefined) size += computeUInt32Size(8, `lastModUsecs`.get)
    for (_v ← `usermeta`) size += computeMessageSize(9, _v)
    for (_v ← `indexes`) size += computeMessageSize(10, _v)
    if (`deleted`.isDefined) size += computeBoolSize(11, `deleted`.get)

    size
  }

  def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): RpbContent = {
    import com.google.protobuf.ExtensionRegistryLite.{ getEmptyRegistry ⇒ _emptyRegistry }
    var __value: com.google.protobuf.ByteString = com.google.protobuf.ByteString.EMPTY
    var __contentType: Option[com.google.protobuf.ByteString] = `contentType`
    var __charset: Option[com.google.protobuf.ByteString] = `charset`
    var __contentEncoding: Option[com.google.protobuf.ByteString] = `contentEncoding`
    var __vtag: Option[com.google.protobuf.ByteString] = `vtag`
    val __links: collection.mutable.Buffer[RpbLink] = `links`.toBuffer
    var __lastMod: Option[Int] = `lastMod`
    var __lastModUsecs: Option[Int] = `lastModUsecs`
    val __usermeta: collection.mutable.Buffer[RpbPair] = `usermeta`.toBuffer
    val __indexes: collection.mutable.Buffer[RpbPair] = `indexes`.toBuffer
    var __deleted: Option[Boolean] = `deleted`

      def __newMerged = RpbContent(
        __value,
        __contentType,
        __charset,
        __contentEncoding,
        __vtag,
        Vector(__links: _*),
        __lastMod,
        __lastModUsecs,
        Vector(__usermeta: _*),
        Vector(__indexes: _*),
        __deleted)
    while (true) in.readTag match {
      case 0       ⇒ return __newMerged
      case 10      ⇒ __value = in.readBytes()
      case 18      ⇒ __contentType = in.readBytes()
      case 26      ⇒ __charset = in.readBytes()
      case 34      ⇒ __contentEncoding = in.readBytes()
      case 42      ⇒ __vtag = in.readBytes()
      case 50      ⇒ __links += readMessage[RpbLink](in, RpbLink.defaultInstance, _emptyRegistry)
      case 56      ⇒ __lastMod = in.readUInt32()
      case 64      ⇒ __lastModUsecs = in.readUInt32()
      case 74      ⇒ __usermeta += readMessage[RpbPair](in, RpbPair.defaultInstance, _emptyRegistry)
      case 82      ⇒ __indexes += readMessage[RpbPair](in, RpbPair.defaultInstance, _emptyRegistry)
      case 88      ⇒ __deleted = in.readBool()
      case default ⇒ if (!in.skipField(default)) return __newMerged
    }
    null
  }

  def mergeFrom(m: RpbContent) = {
    RpbContent(
      m.`value`,
      m.`contentType`.orElse(`contentType`),
      m.`charset`.orElse(`charset`),
      m.`contentEncoding`.orElse(`contentEncoding`),
      m.`vtag`.orElse(`vtag`),
      `links` ++ m.`links`,
      m.`lastMod`.orElse(`lastMod`),
      m.`lastModUsecs`.orElse(`lastModUsecs`),
      `usermeta` ++ m.`usermeta`,
      `indexes` ++ m.`indexes`,
      m.`deleted`.orElse(`deleted`))
  }

  def getDefaultInstanceForType = RpbContent.defaultInstance
  def clear = getDefaultInstanceForType
  def isInitialized = true
  def build = this
  def buildPartial = this
  def newBuilderForType = this
  def toBuilder = this
}

object RpbContent {
  @reflect.BeanProperty val defaultInstance = new RpbContent()

  val VALUE_FIELD_NUMBER = 1
  val CONTENT_TYPE_FIELD_NUMBER = 2
  val CHARSET_FIELD_NUMBER = 3
  val CONTENT_ENCODING_FIELD_NUMBER = 4
  val VTAG_FIELD_NUMBER = 5
  val LINKS_FIELD_NUMBER = 6
  val LAST_MOD_FIELD_NUMBER = 7
  val LAST_MOD_USECS_FIELD_NUMBER = 8
  val USERMETA_FIELD_NUMBER = 9
  val INDEXES_FIELD_NUMBER = 10
  val DELETED_FIELD_NUMBER = 11

}
final case class RpbLink(
  `bucket`: Option[com.google.protobuf.ByteString] = None,
  `key`: Option[com.google.protobuf.ByteString] = None,
  `tag`: Option[com.google.protobuf.ByteString] = None) extends com.google.protobuf.GeneratedMessageLite
    with com.google.protobuf.MessageLite.Builder
    with Message[RpbLink] {

  def setBucket(_f: com.google.protobuf.ByteString) = copy(`bucket` = _f)
  def setKey(_f: com.google.protobuf.ByteString) = copy(`key` = _f)
  def setTag(_f: com.google.protobuf.ByteString) = copy(`tag` = _f)

  def clearBucket = copy(`bucket` = None)
  def clearKey = copy(`key` = None)
  def clearTag = copy(`tag` = None)

  def writeTo(output: com.google.protobuf.CodedOutputStream) {
    if (`bucket`.isDefined) output.writeBytes(1, `bucket`.get)
    if (`key`.isDefined) output.writeBytes(2, `key`.get)
    if (`tag`.isDefined) output.writeBytes(3, `tag`.get)
  }

  lazy val getSerializedSize = {
    import com.google.protobuf.CodedOutputStream._
    var size = 0
    if (`bucket`.isDefined) size += computeBytesSize(1, `bucket`.get)
    if (`key`.isDefined) size += computeBytesSize(2, `key`.get)
    if (`tag`.isDefined) size += computeBytesSize(3, `tag`.get)

    size
  }

  def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): RpbLink = {
    import com.google.protobuf.ExtensionRegistryLite.{ getEmptyRegistry ⇒ _emptyRegistry }
    var __bucket: Option[com.google.protobuf.ByteString] = `bucket`
    var __key: Option[com.google.protobuf.ByteString] = `key`
    var __tag: Option[com.google.protobuf.ByteString] = `tag`

      def __newMerged = RpbLink(
        __bucket,
        __key,
        __tag)
    while (true) in.readTag match {
      case 0       ⇒ return __newMerged
      case 10      ⇒ __bucket = in.readBytes()
      case 18      ⇒ __key = in.readBytes()
      case 26      ⇒ __tag = in.readBytes()
      case default ⇒ if (!in.skipField(default)) return __newMerged
    }
    null
  }

  def mergeFrom(m: RpbLink) = {
    RpbLink(
      m.`bucket`.orElse(`bucket`),
      m.`key`.orElse(`key`),
      m.`tag`.orElse(`tag`))
  }

  def getDefaultInstanceForType = RpbLink.defaultInstance
  def clear = getDefaultInstanceForType
  def isInitialized = true
  def build = this
  def buildPartial = this
  def newBuilderForType = this
  def toBuilder = this
}

object RpbLink {
  @reflect.BeanProperty val defaultInstance = new RpbLink()

  val BUCKET_FIELD_NUMBER = 1
  val KEY_FIELD_NUMBER = 2
  val TAG_FIELD_NUMBER = 3

}
final case class RpbCounterUpdateReq(
  `bucket`: com.google.protobuf.ByteString = com.google.protobuf.ByteString.EMPTY,
  `key`: com.google.protobuf.ByteString = com.google.protobuf.ByteString.EMPTY,
  `amount`: Long = 0L,
  `w`: Option[Int] = None,
  `dw`: Option[Int] = None,
  `pw`: Option[Int] = None,
  `returnvalue`: Option[Boolean] = None) extends com.google.protobuf.GeneratedMessageLite
    with com.google.protobuf.MessageLite.Builder
    with Message[RpbCounterUpdateReq] {

  def setW(_f: Int) = copy(`w` = _f)
  def setDw(_f: Int) = copy(`dw` = _f)
  def setPw(_f: Int) = copy(`pw` = _f)
  def setReturnvalue(_f: Boolean) = copy(`returnvalue` = _f)

  def clearW = copy(`w` = None)
  def clearDw = copy(`dw` = None)
  def clearPw = copy(`pw` = None)
  def clearReturnvalue = copy(`returnvalue` = None)

  def writeTo(output: com.google.protobuf.CodedOutputStream) {
    output.writeBytes(1, `bucket`)
    output.writeBytes(2, `key`)
    output.writeSInt64(3, `amount`)
    if (`w`.isDefined) output.writeUInt32(4, `w`.get)
    if (`dw`.isDefined) output.writeUInt32(5, `dw`.get)
    if (`pw`.isDefined) output.writeUInt32(6, `pw`.get)
    if (`returnvalue`.isDefined) output.writeBool(7, `returnvalue`.get)
  }

  lazy val getSerializedSize = {
    import com.google.protobuf.CodedOutputStream._
    var size = 0
    size += computeBytesSize(1, `bucket`)
    size += computeBytesSize(2, `key`)
    size += computeSInt64Size(3, `amount`)
    if (`w`.isDefined) size += computeUInt32Size(4, `w`.get)
    if (`dw`.isDefined) size += computeUInt32Size(5, `dw`.get)
    if (`pw`.isDefined) size += computeUInt32Size(6, `pw`.get)
    if (`returnvalue`.isDefined) size += computeBoolSize(7, `returnvalue`.get)

    size
  }

  def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): RpbCounterUpdateReq = {
    import com.google.protobuf.ExtensionRegistryLite.{ getEmptyRegistry ⇒ _emptyRegistry }
    var __bucket: com.google.protobuf.ByteString = com.google.protobuf.ByteString.EMPTY
    var __key: com.google.protobuf.ByteString = com.google.protobuf.ByteString.EMPTY
    var __amount: Long = 0L
    var __w: Option[Int] = `w`
    var __dw: Option[Int] = `dw`
    var __pw: Option[Int] = `pw`
    var __returnvalue: Option[Boolean] = `returnvalue`

      def __newMerged = RpbCounterUpdateReq(
        __bucket,
        __key,
        __amount,
        __w,
        __dw,
        __pw,
        __returnvalue)
    while (true) in.readTag match {
      case 0       ⇒ return __newMerged
      case 10      ⇒ __bucket = in.readBytes()
      case 18      ⇒ __key = in.readBytes()
      case 24      ⇒ __amount = in.readSInt64()
      case 32      ⇒ __w = in.readUInt32()
      case 40      ⇒ __dw = in.readUInt32()
      case 48      ⇒ __pw = in.readUInt32()
      case 56      ⇒ __returnvalue = in.readBool()
      case default ⇒ if (!in.skipField(default)) return __newMerged
    }
    null
  }

  def mergeFrom(m: RpbCounterUpdateReq) = {
    RpbCounterUpdateReq(
      m.`bucket`,
      m.`key`,
      m.`amount`,
      m.`w`.orElse(`w`),
      m.`dw`.orElse(`dw`),
      m.`pw`.orElse(`pw`),
      m.`returnvalue`.orElse(`returnvalue`))
  }

  def getDefaultInstanceForType = RpbCounterUpdateReq.defaultInstance
  def clear = getDefaultInstanceForType
  def isInitialized = true
  def build = this
  def buildPartial = this
  def newBuilderForType = this
  def toBuilder = this
}

object RpbCounterUpdateReq {
  @reflect.BeanProperty val defaultInstance = new RpbCounterUpdateReq()

  val BUCKET_FIELD_NUMBER = 1
  val KEY_FIELD_NUMBER = 2
  val AMOUNT_FIELD_NUMBER = 3
  val W_FIELD_NUMBER = 4
  val DW_FIELD_NUMBER = 5
  val PW_FIELD_NUMBER = 6
  val RETURNVALUE_FIELD_NUMBER = 7

}
final case class RpbCounterUpdateResp(
  `value`: Option[Long] = None) extends com.google.protobuf.GeneratedMessageLite
    with com.google.protobuf.MessageLite.Builder
    with Message[RpbCounterUpdateResp] {

  def setValue(_f: Long) = copy(`value` = _f)

  def clearValue = copy(`value` = None)

  def writeTo(output: com.google.protobuf.CodedOutputStream) {
    if (`value`.isDefined) output.writeSInt64(1, `value`.get)
  }

  lazy val getSerializedSize = {
    import com.google.protobuf.CodedOutputStream._
    var size = 0
    if (`value`.isDefined) size += computeSInt64Size(1, `value`.get)

    size
  }

  def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): RpbCounterUpdateResp = {
    import com.google.protobuf.ExtensionRegistryLite.{ getEmptyRegistry ⇒ _emptyRegistry }
    var __value: Option[Long] = `value`

      def __newMerged = RpbCounterUpdateResp(
        __value)
    while (true) in.readTag match {
      case 0       ⇒ return __newMerged
      case 8       ⇒ __value = in.readSInt64()
      case default ⇒ if (!in.skipField(default)) return __newMerged
    }
    null
  }

  def mergeFrom(m: RpbCounterUpdateResp) = {
    RpbCounterUpdateResp(
      m.`value`.orElse(`value`))
  }

  def getDefaultInstanceForType = RpbCounterUpdateResp.defaultInstance
  def clear = getDefaultInstanceForType
  def isInitialized = true
  def build = this
  def buildPartial = this
  def newBuilderForType = this
  def toBuilder = this
}

object RpbCounterUpdateResp {
  @reflect.BeanProperty val defaultInstance = new RpbCounterUpdateResp()

  val VALUE_FIELD_NUMBER = 1

}
final case class RpbCounterGetReq(
  `bucket`: com.google.protobuf.ByteString = com.google.protobuf.ByteString.EMPTY,
  `key`: com.google.protobuf.ByteString = com.google.protobuf.ByteString.EMPTY,
  `r`: Option[Int] = None,
  `pr`: Option[Int] = None,
  `basicQuorum`: Option[Boolean] = None,
  `notfoundOk`: Option[Boolean] = None) extends com.google.protobuf.GeneratedMessageLite
    with com.google.protobuf.MessageLite.Builder
    with Message[RpbCounterGetReq] {

  def setR(_f: Int) = copy(`r` = _f)
  def setPr(_f: Int) = copy(`pr` = _f)
  def setBasicQuorum(_f: Boolean) = copy(`basicQuorum` = _f)
  def setNotfoundOk(_f: Boolean) = copy(`notfoundOk` = _f)

  def clearR = copy(`r` = None)
  def clearPr = copy(`pr` = None)
  def clearBasicQuorum = copy(`basicQuorum` = None)
  def clearNotfoundOk = copy(`notfoundOk` = None)

  def writeTo(output: com.google.protobuf.CodedOutputStream) {
    output.writeBytes(1, `bucket`)
    output.writeBytes(2, `key`)
    if (`r`.isDefined) output.writeUInt32(3, `r`.get)
    if (`pr`.isDefined) output.writeUInt32(4, `pr`.get)
    if (`basicQuorum`.isDefined) output.writeBool(5, `basicQuorum`.get)
    if (`notfoundOk`.isDefined) output.writeBool(6, `notfoundOk`.get)
  }

  lazy val getSerializedSize = {
    import com.google.protobuf.CodedOutputStream._
    var size = 0
    size += computeBytesSize(1, `bucket`)
    size += computeBytesSize(2, `key`)
    if (`r`.isDefined) size += computeUInt32Size(3, `r`.get)
    if (`pr`.isDefined) size += computeUInt32Size(4, `pr`.get)
    if (`basicQuorum`.isDefined) size += computeBoolSize(5, `basicQuorum`.get)
    if (`notfoundOk`.isDefined) size += computeBoolSize(6, `notfoundOk`.get)

    size
  }

  def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): RpbCounterGetReq = {
    import com.google.protobuf.ExtensionRegistryLite.{ getEmptyRegistry ⇒ _emptyRegistry }
    var __bucket: com.google.protobuf.ByteString = com.google.protobuf.ByteString.EMPTY
    var __key: com.google.protobuf.ByteString = com.google.protobuf.ByteString.EMPTY
    var __r: Option[Int] = `r`
    var __pr: Option[Int] = `pr`
    var __basicQuorum: Option[Boolean] = `basicQuorum`
    var __notfoundOk: Option[Boolean] = `notfoundOk`

      def __newMerged = RpbCounterGetReq(
        __bucket,
        __key,
        __r,
        __pr,
        __basicQuorum,
        __notfoundOk)
    while (true) in.readTag match {
      case 0       ⇒ return __newMerged
      case 10      ⇒ __bucket = in.readBytes()
      case 18      ⇒ __key = in.readBytes()
      case 24      ⇒ __r = in.readUInt32()
      case 32      ⇒ __pr = in.readUInt32()
      case 40      ⇒ __basicQuorum = in.readBool()
      case 48      ⇒ __notfoundOk = in.readBool()
      case default ⇒ if (!in.skipField(default)) return __newMerged
    }
    null
  }

  def mergeFrom(m: RpbCounterGetReq) = {
    RpbCounterGetReq(
      m.`bucket`,
      m.`key`,
      m.`r`.orElse(`r`),
      m.`pr`.orElse(`pr`),
      m.`basicQuorum`.orElse(`basicQuorum`),
      m.`notfoundOk`.orElse(`notfoundOk`))
  }

  def getDefaultInstanceForType = RpbCounterGetReq.defaultInstance
  def clear = getDefaultInstanceForType
  def isInitialized = true
  def build = this
  def buildPartial = this
  def newBuilderForType = this
  def toBuilder = this
}

object RpbCounterGetReq {
  @reflect.BeanProperty val defaultInstance = new RpbCounterGetReq()

  val BUCKET_FIELD_NUMBER = 1
  val KEY_FIELD_NUMBER = 2
  val R_FIELD_NUMBER = 3
  val PR_FIELD_NUMBER = 4
  val BASIC_QUORUM_FIELD_NUMBER = 5
  val NOTFOUND_OK_FIELD_NUMBER = 6

}
final case class RpbCounterGetResp(
  `value`: Option[Long] = None) extends com.google.protobuf.GeneratedMessageLite
    with com.google.protobuf.MessageLite.Builder
    with Message[RpbCounterGetResp] {

  def setValue(_f: Long) = copy(`value` = _f)

  def clearValue = copy(`value` = None)

  def writeTo(output: com.google.protobuf.CodedOutputStream) {
    if (`value`.isDefined) output.writeSInt64(1, `value`.get)
  }

  lazy val getSerializedSize = {
    import com.google.protobuf.CodedOutputStream._
    var size = 0
    if (`value`.isDefined) size += computeSInt64Size(1, `value`.get)

    size
  }

  def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): RpbCounterGetResp = {
    import com.google.protobuf.ExtensionRegistryLite.{ getEmptyRegistry ⇒ _emptyRegistry }
    var __value: Option[Long] = `value`

      def __newMerged = RpbCounterGetResp(
        __value)
    while (true) in.readTag match {
      case 0       ⇒ return __newMerged
      case 8       ⇒ __value = in.readSInt64()
      case default ⇒ if (!in.skipField(default)) return __newMerged
    }
    null
  }

  def mergeFrom(m: RpbCounterGetResp) = {
    RpbCounterGetResp(
      m.`value`.orElse(`value`))
  }

  def getDefaultInstanceForType = RpbCounterGetResp.defaultInstance
  def clear = getDefaultInstanceForType
  def isInitialized = true
  def build = this
  def buildPartial = this
  def newBuilderForType = this
  def toBuilder = this
}

object RpbCounterGetResp {
  @reflect.BeanProperty val defaultInstance = new RpbCounterGetResp()

  val VALUE_FIELD_NUMBER = 1

}

object RiakKvPB {
  def registerAllExtensions(registry: com.google.protobuf.ExtensionRegistryLite) {
  }

}
